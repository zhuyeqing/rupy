#summary How to fuse HTTP network async.
#labels Phase-Design

This requires latest [http://rupy.se/rupy.zip rupy] and [http://root.rupy.se/code Async.java].

<font color="red">
_Work in progress: Async.java is very stable, but we have not implemented chunked responses yet._
</font>

This is how the current client/server tools work in a co-operative solution:

  * `brow` = <font color="CD5C5C">`sync`</font> `req`         <font color="grey"> `(browser)`</font>
  * `serv` = <font color="CD5C5C">`sync`</font> `res`         <font color="grey"> `(database)`</font>

{{{
time <----------------  goes forth & back  ------------------>
wait      ↓↓↓↓   ↓↓↓↓↓   ↓↓↓↓↓↓↓↓↓↓↓   ↓↓↓↓↓   ↓↓↓↓

+--------+    +---------+           +---------+    +---------+
|        | -> |         | ---+----> |         |    |         |
|  brow  |    |  sync1  |    |      |  sync2  | .. |  serv2  |
|        | <- |         | <----+--- |         |    |         |
+--------+    +---------+    | |    +---------+    +---------+
                             | |
                         +---------+
                         |         |
                         |  serv1  |
                         |         |
                         +---------+
}}}

  * `sync` = <font color="CD5C5C">`sync`</font> `req` & `res` <font color="grey"> `(your web-server)`</font>

The idea is to only "wait" in the network (no related <font color="red">`IO-wait`</font>) and to wait for multiple things at the same time:

{{{
time <---------------  goes forth & back  --------------->
wait      ↓↓↓↓           ↓↓   ↓↓           ↓↓↓↓

+--------+    +---------+       +---------+    +---------+
|        | -> |         | -+--> |         |    |         |
|  brow  |    |  asyn1  |  |    |  asyn2  | .. |  serv2  |
|        | <- |         | <--+- |         |    |         |
+--------+    +---------+  | |  +---------+    +---------+
                           | |
                           | +---+
                           +---+ |
                               | |
                           +---------+
                           |         |
                           |  serv1  |
                           |         |
                           +---------+
}}}

  * `asyn` = <font color="5CCD5C">`asyn`</font> `req` & `res` <font color="grey">`(`</font><font color="green">`fuse`</font><font color="grey">`)`</font>

For this we introduce a new concept; <font color="green">`fuse`</font>; you can clearly see that the compounded savings in terms of time and wait are huge, specially when the system scales in concurrency and depth. As a matter of fact, you can't scale at all without <font color="5CCD5C">`asyn`</font> `req`; and with <font color="5CCD5C">`asyn`</font> `req` & `res` you're even better off.

Another way to describe this is time and <font color="red">`IO-wait`</font> shown in the graph below:

  # = <font color="CD5C5C">`sync`</font> `req` & `res` <font color="grey"> `(your web-server)`</font>
  # = <font color="5CCD5C">`asyn`</font> `req` <font color="grey"> `(netflix)`</font>
  # = <font color="5CCD5C">`asyn`</font> `req` & `res` <font color="grey">`(`</font><font color="green">`fuse`</font><font color="grey">`)`</font>

http://rupy.se/fuse.gif

If you want to use [https://code.google.com/p/rupy/wiki/Process µSOA] this is the most performant way to build your services network. You can even use this as a load balancer.

Another use case for this is our cluster database [https://code.google.com/p/rupy/wiki/Persistence root].

This [http://root.rupy.se/fuse example] fuses data <font color="5CCD5C">`asyn`</font> from multiple servers to your browser ASAP on a raspberry pi with zero thread <font color="red">`IO-wait`</font>:
{{{
// TODO: Improve latch.
public static class Fuse extends Service {
	static Async async;

	public void create(Daemon daemon) throws Exception { async = new Async(true); async.start(5); }
	public void destroy() throws Exception { async.stop(); }
	public String path() { return "/fuse"; }

	public void filter(final Event event) throws Event, Exception {
		Output out = event.output();

		if(event.push()) {
			Http[] http = (Http[]) event.query().get("http");

			int done = 0;

			for(int i = 0; i < http.length; i++) {
				if(http[i].print()) {
					done++;
				}
			}

			if(done == http.length) {
				out.println("</body></html>");
				out.finish();
			}

			out.flush();
		}
		else {
			event.query().put("time", System.currentTimeMillis());
			event.reply().type("text/html; charset=UTF-8");
			event.hold();

			Http[] http = new Http[2];

			String path = "/v1/public/yql" +
			"?q=select%20*%20from%20yahoo.finance.xchange%20where%20pair%20in%20(%22USDSEK%22)" +
			"&format=json&env=store%3A%2F%2Fdatatables.org%2Falltableswithkeys";

			http[0] = new Http("one", "strip.rupy.se", "/?a=martin+kellerman&body", event);
			http[1] = new Http("two", "query.yahooapis.com", path, event);

			for(int i = 0; i < http.length; i++) {
				// The 10 at the end is very important.
				// It means the socket will be kept alive 
				// for 10 seconds since last active.
				async.send(http[i].host, http[i], 10);
			}

			event.query().put("http", http);
		}
	}

	public static class Http extends Work {
		private String name;
		private String host;
		private String path;
		private String body;
		private Event event;

		public Http(String name, String host, String path, Event event) {
			this.name = name;
			this.host = host;
			this.path = path;
			this.event = event;
		}

		public boolean print() throws Exception {
			if(event.query().get(name) instanceof Http) {
				long time = System.currentTimeMillis() - event.big("time");
				System.out.println("  " + name + " " + time + " ms.");
				event.output().println(body);
				event.query().put(name, "done");
				return true;
			}
			else if(event.query().get(name) instanceof String) {
				return ((String) event.query().get(name)).equals("done");
			}

			return false;
		}

		public void send(Call call) throws Exception {
			call.get(path, "Host: " + host + "\r\n");
		}

		public void read(String body) throws Exception {
			this.body = body;
			event.query().put(name, this);
			System.out.println("  " + name + " success " + event.reply().wakeup());
		}

		public void fail(String host, Exception e) throws Exception {
			if(e instanceof Timeout) {
				System.out.println("  " + e);
				async.send(host, this, 10);
			}
			else {
				e.printStackTrace();
				event.query().put("response", e.toString());
				System.out.println("  " + name + " failure " + event.reply().wakeup());
			}
		}
	};
}
}}}